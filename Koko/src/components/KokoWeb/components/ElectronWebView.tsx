import React, { useEffect, useRef } from 'react';

// Declaraci√≥n de tipos para webview de Electron
declare global {
  namespace JSX {
    interface IntrinsicElements {
      webview: React.DetailedHTMLProps<React.HTMLAttributes<HTMLElement>, HTMLElement> & {
        src?: string;
        allowpopups?: boolean;
        webpreferences?: string;
        useragent?: string;
      };
    }
  }
}

interface ElectronWebViewProps {
  url: string;
  setStatus: (status: string) => void;
  onUrlChange?: (url: string, title?: string) => void;
  onNewTab?: (url: string, title?: string) => void; // Nueva funci√≥n para crear pesta√±as
}

const ElectronWebView: React.FC<ElectronWebViewProps> = ({ url, setStatus, onUrlChange, onNewTab }) => {
  const webviewRef = useRef<HTMLElement>(null);
  const retryCountRef = useRef<number>(0); // Contador de reintentos para evitar bucles
  const lastErrorUrlRef = useRef<string>(''); // √öltima URL que caus√≥ error
  const isBlockedDomainRef = useRef<boolean>(false); // Flag para dominios bloqueados
  const currentUrlRef = useRef<string>(''); // URL actual para evitar recargas innecesarias

  // üöÄ DETECCI√ìN INMEDIATA de dominios bloqueados (antes de cargar)
  const checkForBlockedDomain = (targetUrl: string) => {
    if (!targetUrl) return false;
    
    // üö´ COMPLETAMENTE DESACTIVADO: Permitir que todos los dominios funcionen en webview
    return false; // Siempre permitir todos los dominios
  };

  // üõ°Ô∏è INTERCEPTAR URL ANTES DE CARGAR
  useEffect(() => {
    // Reducir logs para evitar spam
    if (Date.now() - (window as any).__lastUrlLog > 1000) {
      console.log('üîç Verificando URL:', url);
      (window as any).__lastUrlLog = Date.now();
    }
    
    if (checkForBlockedDomain(url)) {
      console.log('üõë URL BLOQUEADA - NO CARGAR EN WEBVIEW');
      return; // No proceder con la configuraci√≥n del webview
    }
    
  }, [url]); // Ejecutar cada vez que cambie la URL

  useEffect(() => {
    const webview = webviewRef.current as any;
    if (!webview || isBlockedDomainRef.current) {
      console.log('‚ö†Ô∏è Webview no disponible o dominio bloqueado - saltando configuraci√≥n');
      return;
    }

    // Event listeners para webview
    const handleLoadStart = () => {
      // ÔøΩ VERIFICACI√ìN ADICIONAL en load start
      const currentUrl = webview.getURL && webview.getURL() || url;
      
      if (checkForBlockedDomain(currentUrl)) {
        console.log('üõë Carga interrumpida - dominio bloqueado detectado autom√°ticamente');
        return; // No proceder con la carga
      }
      
      setStatus('cargando...');
    };

    const handleLoadStop = () => {
      setStatus('listo');
      
      // ‚úÖ Resetear contador de errores en carga exitosa
      retryCountRef.current = 0;
      lastErrorUrlRef.current = '';
      
      // Obtener la URL actual y el t√≠tulo cuando termine de cargar
      if (onUrlChange && webview.getURL) {
        const currentUrl = webview.getURL();
        const currentTitle = webview.getTitle() || 'Sin t√≠tulo';
        onUrlChange(currentUrl, currentTitle);
      }
    };

    const handleLoadFail = (event: any) => {
      const currentUrl = event.validatedURL || url;
      
      console.error('üö® Error de carga en webview:', {
        errorCode: event.errorCode,
        errorDescription: event.errorDescription,
        url: currentUrl,
        isMainFrame: event.isMainFrame,
        retryCount: retryCountRef.current
      });
      
      setStatus(`Error: ${event.errorDescription || 'No se pudo cargar la p√°gina'}`);
      
      // üõ°Ô∏è EVITAR bucles con about:blank
      if (currentUrl === 'about:blank' || currentUrl.includes('about:blank')) {
        console.log('üõë Error en about:blank - detener inmediatamente sin redirecci√≥n');
        setStatus('P√°gina de inicio - Use la barra de direcciones para navegar');
        return; // NO hacer nada m√°s
      }
      
      // üõ°Ô∏è Protecci√≥n ESTRICTA contra bucles infinitos
      if (currentUrl === lastErrorUrlRef.current) {
        retryCountRef.current += 1;
        console.log(`‚ö†Ô∏è Reintento #${retryCountRef.current} para la misma URL:`, currentUrl);
        
        if (retryCountRef.current >= 1) { // Solo 1 reintento
          console.log('üõë Un solo reintento permitido - DETENIENDO bucle definitivamente');
          
          // NO redirigir a about:blank, simplemente mostrar error est√°tico
          setStatus('Sitio no disponible - Use la barra de direcciones para navegar a otro sitio');
          return; // SALIR definitivamente sin cambiar URL
        }
      } else {
        // Nueva URL que falla, resetear contador
        retryCountRef.current = 1;
        lastErrorUrlRef.current = currentUrl;
      }
      
      // üß† Manejo inteligente de errores ERR_ABORTED - SIN ventanas externas
      if (event.errorCode === -3) { // ERR_ABORTED
        console.log('üîÑ Error ERR_ABORTED detectado, intentando fallback interno...');
        
        // FORZAR PARADA del bucle infinito despu√©s del primer intento
        if (retryCountRef.current === 1) {
          console.log('üõë PRIMER ERROR ERR_ABORTED - Deteniendo bucle sin redirecci√≥n');
          
          // NO redirigir a ninguna URL, solo mostrar mensaje de error
          setStatus('Sitio no es compatible con webview - Use la barra de direcciones para navegar');
          return; // DETENER aqu√≠, no m√°s reintentos
        }
        
        // Si es reintento, simplemente detener
        console.log('üõë ERR_ABORTED en reintento - DETENIENDO bucle definitivamente');
        setStatus('Sitio no compatible con webview - Usar navegaci√≥n directa');
        return;
      }
      
      // ERR_BLOCKED_BY_RESPONSE espec√≠fico para Google
      if (event.errorCode === -20 && currentUrl.includes('google.com')) {
        console.log('üö® ERR_BLOCKED_BY_RESPONSE en Google - intentando navegaci√≥n inteligente...');
        
        // Usar navegaci√≥n inteligente tambi√©n para ERR_BLOCKED_BY_RESPONSE
        if (false) { // DESACTIVADO: No usar navegaci√≥n inteligente autom√°tica
          console.log('üéØ Usando navegaci√≥n inteligente para ERR_BLOCKED_BY_RESPONSE');
          window.electronAPI?.navigation.openBrowserTab(currentUrl);
          return;
        }
        
        console.log('üîÑ Intentando recargar con delay m√°s largo...');
        setTimeout(() => {
          if (webview && webview.reload) {
            webview.reload();
          }
        }, 5000);
      } else if (event.errorCode === -6) { // ERR_FILE_NOT_FOUND
        console.log('üìÑ Archivo no encontrado, redirigiendo a Google...');
        if (onUrlChange) {
          onUrlChange('https://www.google.com', 'Google - P√°gina no encontrada');
        }
      }
    };

    const handleNavigate = (event: any) => {
      console.log('üîÑ Navegaci√≥n detectada:', event.url);
      
      // üõë BLOQUEO TOTAL: YouTube playlist - NO notificar cambios de URL
      if (event.url && event.url.includes('youtube.com/watch') && url.includes('youtube.com/watch')) {
        console.log('üõë YouTube playlist BLOQUEADO - NO notificar cambio de URL para evitar bucles');
        setStatus('YouTube: Reproduciendo playlist');
        // NO llamar onUrlChange - esto es lo que causa los bucles
        return;
      }
      
      // Para primera carga de YouTube o navegaci√≥n a YouTube desde otro sitio
      if (event.url && event.url.includes('youtube.com/watch') && !url.includes('youtube.com/watch')) {
        console.log('üéµ Primera carga de YouTube - permitir');
        setStatus('YouTube: Cargando video');
        if (onUrlChange && event.url) {
          onUrlChange(event.url);
        }
        return;
      }
      
      setStatus(`Navegando a: ${event.url}`);
      
      // Para otros sitios, proceder normalmente
      if (onUrlChange && event.url) {
        onUrlChange(event.url);
      }
    };

    const handleDomReady = () => {
      console.log('üéØ DOM listo para:', url);
      
      // üõë YouTube playlist: NO actualizar informaci√≥n para evitar bucles
      if (url.includes('youtube.com/watch') && webview.getURL && webview.getURL().includes('youtube.com/watch')) {
        console.log('üõë YouTube playlist DOM ready - NO actualizar para evitar bucles');
        return;
      }
      
      // Actualizar t√≠tulo cuando el DOM est√© listo (solo para sitios no-YouTube playlist)
      if (onUrlChange && webview.getURL && webview.getTitle) {
        const currentUrl = webview.getURL();
        const currentTitle = webview.getTitle() || 'Sin t√≠tulo';
        console.log('üìÑ Informaci√≥n de p√°gina:', { currentUrl, currentTitle });
        onUrlChange(currentUrl, currentTitle);
      }
      
      // Log espec√≠fico para Google
      if (url.includes('google.com')) {
        console.log('üéâ Google cargado exitosamente en webview!');
      }
    };

    // Agregar event listeners
    webview.addEventListener('did-start-loading', handleLoadStart);
    webview.addEventListener('did-stop-loading', handleLoadStop);
    webview.addEventListener('did-fail-load', handleLoadFail);
    
    // üõë YouTube: NO agregar will-navigate listener para evitar bucles en playlists
    if (!url.includes('youtube.com/watch')) {
      webview.addEventListener('will-navigate', handleNavigate);
      console.log('‚úÖ will-navigate listener agregado para sitio no-YouTube');
    } else {
      console.log('üõë YouTube detectado - will-navigate listener NO agregado para evitar bucles');
    }
    
    webview.addEventListener('dom-ready', handleDomReady);

    // Event listener para manejar nuevas ventanas como nuevas pesta√±as
    const handleNewWindow = (event: any) => {
      console.log('ü™ü Nueva ventana solicitada:', event.url);
      
      // Prevenir que se abra una ventana flotante
      event.preventDefault();
      
      // Si tenemos callback para crear nueva pesta√±a, usarlo
      if (onNewTab && event.url) {
        console.log('üÜï Creando nueva pesta√±a en lugar de ventana flotante');
        onNewTab(event.url, event.frameName || 'Nueva pesta√±a');
      } else {
        console.log('‚ö†Ô∏è No hay callback de nueva pesta√±a disponible, usando navegaci√≥n por defecto');
        // Fallback: navegar en la pesta√±a actual
        if (onUrlChange) {
          onUrlChange(event.url);
        }
      }
    };
    webview.addEventListener('new-window', handleNewWindow);

    // Cleanup
    return () => {
      webview.removeEventListener('did-start-loading', handleLoadStart);
      webview.removeEventListener('did-stop-loading', handleLoadStop);
      webview.removeEventListener('did-fail-load', handleLoadFail);
      
      // Solo remover will-navigate si fue agregado
      if (!url.includes('youtube.com/watch')) {
        webview.removeEventListener('will-navigate', handleNavigate);
      }
      
      webview.removeEventListener('dom-ready', handleDomReady);
      webview.removeEventListener('new-window', handleNewWindow);
    };
  }, [setStatus]);

  // Actualizar URL cuando cambie - SOLO si no es dominio bloqueado
  useEffect(() => {
    const webview = webviewRef.current as any;
    if (webview && url && !isBlockedDomainRef.current) {
      // üéµ YouTube: NO forzar cambio de src si ya estamos en YouTube
      // Dejar que YouTube maneje su propia navegaci√≥n interna
      if (url.includes('youtube.com/watch') && currentUrlRef.current.includes('youtube.com/watch')) {
        console.log('üéµ YouTube navegaci√≥n interna - NO cambiar src, dejar que YouTube maneje');
        currentUrlRef.current = url; // Actualizar referencia pero no el webview
        return;
      }
      
      // Para otros sitios o primera carga de YouTube, cambiar src normalmente
      if (webview.src !== url) {
        console.log('üîÑ Actualizando URL de webview:', url);
        webview.src = url;
        currentUrlRef.current = url;
      }
    }
  }, [url]);

  // üö´ NO RENDERIZAR WEBVIEW para dominios bloqueados
  if (isBlockedDomainRef.current) {
    return (
      <div className="flex-1 bg-gray-100 flex items-center justify-center">
        <div className="text-center p-8">
          <div className="text-2xl mb-4">üöÄ</div>
          <div className="text-lg font-medium text-gray-700 mb-2">
            Abriendo en ventana externa
          </div>
          <div className="text-sm text-gray-500">
            Este sitio requiere ventana externa para funcionar correctamente
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="flex-1 bg-white">
      <webview
        ref={webviewRef}
        src={url}
        style={{
          width: '100%',
          height: '100%',
          border: 'none'
        }}
        allowpopups={true}
        webpreferences="webSecurity=false,allowRunningInsecureContent=true,contextIsolation=false,nodeIntegration=false,experimentalFeatures=true,disableWebSecurity=true,allowDisplayingInsecureContent=true"
        useragent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 KokoWebBrowser/1.0"
        partition="persist:webview"
      />
    </div>
  );
};

export default ElectronWebView;